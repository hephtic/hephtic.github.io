<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nicholas Tan - Simulations</title>
  <link rel="stylesheet" href="https://latex.vercel.app/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="../style.css">
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    /* Minimal simulation-specific styles */
    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin: 2rem 0;
    }
    
    @media (max-width: 768px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .control-group {
      margin-bottom: 1.5rem;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .slider {
      flex: 1;
    }
    
    .value-display {
      min-width: 60px;
      text-align: right;
      font-family: monospace;
      font-weight: 600;
    }
    
    .metrics-display {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .metric {
      text-align: center;
      padding: 1rem;
      border-radius: 8px;
    }
    
    .metric-label {
      font-size: 0.8rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
      opacity: 0.7;
    }
    
    .metric-value {
      font-size: 1.2rem;
      font-weight: 700;
      font-family: monospace;
    }
    
    .probability-bars {
      margin: 1rem 0;
    }
    
    .prob-bar {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .prob-label {
      width: 30px;
      font-weight: 600;
    }
    
    .prob-visual {
      flex: 1;
      height: 20px;
      background: rgba(128, 128, 128, 0.2);
      border-radius: 10px;
      margin: 0 0.5rem;
      position: relative;
      overflow: hidden;
    }
    
    .prob-fill {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    
    .prob-fill.symbol-a { background: #6ea8fe; }
    .prob-fill.symbol-b { background: #60d394; }
    .prob-fill.symbol-c { background: #ff6b6b; }
    
    .prob-value {
      width: 50px;
      text-align: right;
      font-family: monospace;
      font-weight: 600;
    }
    
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .status-success {
      background: rgba(96, 211, 148, 0.2);
      color: #60d394;
    }
    
    .status-warning {
      background: rgba(255, 180, 84, 0.2);
      color: #ffb454;
    }
    
    .status-error {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .message-preview {
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      word-break: break-all;
      max-height: 150px;
      overflow-y: auto;
      padding: 1rem;
      border-radius: 8px;
    }

    .btn, select {
      background: var(--sidebar-bg) !important;
      color: var(--text-color) !important;
      border: 1px solid var(--border-color, rgba(255, 255, 255, 0.1)) !important;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }

    .btn:hover {
      background: var(--hover-bg, rgba(255, 255, 255, 0.1)) !important;
}
  </style>

  <script>
    const theme = localStorage.getItem('theme');
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
</head>
<body>
  <!-- Particles Background -->
  <div id="particles-js"></div>

  <!-- Sidebar -->
  <div class="sidebar-hover-zone"></div>
  <nav class="sidebar expanded">
    <ul>
      <li><a href="../index.html"><i class="fas fa-house"></i><span>Home</span></a></li>
      <li><a href="../projects.html"><i class="fas fa-diagram-project"></i><span>Projects</span></a></li>
      <li><a href="../simulations.html"><i class="fas fa-computer"></i><span>Simulations</span></a></li>
      <li><a href="../reading-list.html"><i class="fas fa-book-open-reader"></i><span>Reading List</span></a></li>
      <li><a href="../blog.html"><i class="fas fa-pen-nib"></i><span>Blog</span></a></li>
      <li><a href="../about.html"><i class="fas fa-circle-info"></i><span>About</span></a></li>
    </ul>
  </nav>

  <!-- Main Content -->
  <div class="main-content">
    <div class="container">
      <header>
        <h1>Entropy Encoding and Redundancy</h1>
      </header>
      
      <main>
        <p style="text-indent: 20px;">
          Suppose we had a way to formalize uncertainty of events. This is what <strong>Information Theory</strong> is. Events can be encoded with information (bits) and 
          explore the fundamental trade-offs between <em>compression efficiency</em> and <em>error resilience</em> in data transmission.
        </p>
        <section>
          <h3>Source and Message</h3>
          <p>
            Information theory begins with a source that generates symbols according to some probability distribution. 
            The <strong>entropy</strong> of this source determines the theoretical minimum bits needed per symbol. 
            More predictable sources (skewed distributions) have lower entropy and can be compressed more effectively.
          </p>
          
          <h4><i class="fas fa-lightbulb"></i> Try This Experiment:</h4>
          <ol>
            <li>Set Symbol A to 0.8, B to 0.15 (highly skewed distribution)</li>
            <li>Generate and encode with Huffman - notice the compression gain</li>
            <li>Set error rate to 0.1 (10% bit errors)</li>
            <li>Compare transmission with no correction vs 3x repetition</li>
            <li>Observe the efficiency vs reliability trade-off!</li>
          </ol>

          <div class="controls-grid">
            <div>
              <h4>Symbol Probabilities</h4>
              <div class="control-group">
                <label>Symbol A Probability</label>
                <div class="slider-container">
                  <input type="range" id="probA" class="slider" min="0" max="0.95" step="0.01" value="0.7">
                  <span class="value-display" id="probA-value">0.70</span>
                </div>
              </div>
              
              <div class="control-group">
                <label>Symbol B Probability</label>
                <div class="slider-container">
                  <input type="range" id="probB" class="slider" min="0" max="0.95" step="0.01" value="0.2">
                  <span class="value-display" id="probB-value">0.20</span>
                </div>
              </div>

              <div class="probability-bars">
                <div class="prob-bar">
                  <span class="prob-label">A:</span>
                  <div class="prob-visual">
                    <div class="prob-fill symbol-a" id="probA-bar" style="width: 70%"></div>
                  </div>
                  <span class="prob-value" id="probA-display">0.70</span>
                </div>
                <div class="prob-bar">
                  <span class="prob-label">B:</span>
                  <div class="prob-visual">
                    <div class="prob-fill symbol-b" id="probB-bar" style="width: 20%"></div>
                  </div>
                  <span class="prob-value" id="probB-display">0.20</span>
                </div>
                <div class="prob-bar">
                  <span class="prob-label">C:</span>
                  <div class="prob-visual">
                    <div class="prob-fill symbol-c" id="probC-bar" style="width: 10%"></div>
                  </div>
                  <span class="prob-value" id="probC-display">0.10</span>
                </div>
              </div>
              
              <div class="control-group">
                <label>Message Length</label>
                <div class="slider-container">
                  <input type="range" id="msgLength" class="slider" min="50" max="1000" step="10" value="200">
                  <span class="value-display" id="msgLength-value">200</span>
                </div>
              </div>
              
              <button class="btn" id="generateMsg" style="width: 100%;">
                <i class="fas fa-refresh"></i> Generate New Message
              </button>
            </div>

            <div>
              <h4>Source Metrics</h4>
              <div class="metrics-display">
                <div class="metric">
                  <div class="metric-label">Entropy H(X)</div>
                  <div class="metric-value" id="entropy-value">1.157</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Max Entropy</div>
                  <div class="metric-value">1.585</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Efficiency</div>
                  <div class="metric-value" id="efficiency-value">73%</div>
                </div>
              </div>

              <div class="message-preview">
                <strong>Generated Message (first 100 symbols):</strong><br>
                <div id="message-preview">Click "Generate New Message" to start...</div>
              </div>
            </div>
          </div>

          <canvas id="distributionChart" style="max-height: 300px;"></canvas>
        </section>

        <section>
          <h3>Source Encoding</h3>
          <p>
            Source encoding aims to represent the message using the fewest possible bits. <strong>Huffman coding</strong> 
            assigns shorter codes to more frequent symbols, approaching the entropy limit. Fixed-length encoding uses 
            the same number of bits for every symbol, which is simpler but less efficient for skewed distributions.
          </p>

          <div class="controls-grid">
            <div>
              <h4>Encoding Method</h4>
              <div class="control-group">
                <label>Choose Encoding:</label>
                <select id="encodingMethod" style="width: 100%; padding: 0.5rem;">
                  <option value="huffman">Huffman Coding (Optimal)</option>
                  <option value="fixed">Fixed-Length Coding</option>
                </select>
              </div>

              <div id="huffman-codes" class="control-group">
                <label>Generated Codes:</label>
                <div class="message-preview" id="codes-display">
                  Generate a message first...
                </div>
              </div>

              <button class="btn" id="encodeMsg" style="width: 100%;">
                <i class="fas fa-code"></i> Encode Message
              </button>
            </div>

            <div>
              <h4>Encoding Results</h4>
              <div class="metrics-display">
                <div class="metric">
                  <div class="metric-label">Avg Bits/Symbol</div>
                  <div class="metric-value" id="avgBits-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Total Bits</div>
                  <div class="metric-value" id="totalBits-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Compression</div>
                  <div class="metric-value" id="compression-value">—</div>
                </div>
              </div>

              <div class="message-preview">
                <strong>Encoded Bits (first 200):</strong><br>
                <div id="encoded-preview">Encode a message first...</div>
              </div>

              <div id="encoding-status" class="status-indicator status-success" style="margin-top: 1rem; display: none;">
                <i class="fas fa-check-circle"></i>
                <span>Ready for transmission</span>
              </div>
            </div>
          </div>

          <canvas id="encodingChart" style="max-height: 300px;"></canvas>
        </section>

        <section>
          <h3>Channel and Error Correction</h3>
          <p>
            Real communication channels introduce noise that can flip bits. <strong>Error correction codes</strong> add 
            redundancy to detect and correct these errors. This creates a fundamental trade-off: more redundancy means 
            better error protection but lower bandwidth efficiency. The choice depends on channel quality and application requirements.
          </p>

          <div class="controls-grid">
            <div>
              <h4>Channel Parameters</h4>
              <div class="control-group">
                <label>Bit Error Rate</label>
                <div class="slider-container">
                  <input type="range" id="errorRate" class="slider" min="0" max="0.3" step="0.005" value="0.05">
                  <span class="value-display" id="errorRate-value">0.050</span>
                </div>
              </div>

              <div class="control-group">
                <label>Error Correction:</label>
                <select id="errorCorrection" style="width: 100%; padding: 0.5rem;">
                  <option value="none">No Error Correction</option>
                  <option value="repetition3">3x Repetition Code</option>
                  <option value="repetition5">5x Repetition Code</option>
                </select>
              </div>

              <button class="btn" id="transmitMsg" style="width: 100%;">
                <i class="fas fa-paper-plane"></i> Transmit Message
              </button>
            </div>

            <div>
              <h4>Transmission Results</h4>
              <div class="metrics-display">
                <div class="metric">
                  <div class="metric-label">Bits Sent</div>
                  <div class="metric-value" id="bitsSent-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Overhead</div>
                  <div class="metric-value" id="overhead-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Errors Fixed</div>
                  <div class="metric-value" id="errorsFixed-value">—</div>
                </div>
              </div>

              <div class="metrics-display">
                <div class="metric">
                  <div class="metric-label">Input BER</div>
                  <div class="metric-value" id="inputBER-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Output BER</div>
                  <div class="metric-value" id="outputBER-value">—</div>
                </div>
                <div class="metric">
                  <div class="metric-label">Quality</div>
                  <div class="metric-value" id="quality-value">—</div>
                </div>
              </div>

              <div id="transmission-status" class="status-indicator status-success" style="margin-top: 1rem; display: none;">
                <i class="fas fa-check-circle"></i>
                <span>Transmission complete</span>
              </div>
            </div>
          </div>

          <canvas id="tradeoffChart" style="max-height: 300px;"></canvas>
        </section>
      </main>
    </div>
  </div>

  
  <!-- Control buttons -->
  <button id="theme-toggle" aria-label="Toggle Dark Mode">
    <i id="theme-icon" class="fas fa-moon"></i>
  </button>
 <!-- Hamburger Button -->
<button id="sidebar-toggle" aria-label="Toggle Sidebar" onclick="toggleMobileMenu()">
  <i class="fas fa-bars"></i>
</button>

  <script src="../script.js" defer></script>
  
  <script>
    // Information Theory Simulation Logic
    let messageSymbols = [];
    let encodedBits = '';
    let huffmanCodes = {};
    let fixedCodes = { 'A': '00', 'B': '01', 'C': '10' };

    // Utility functions
    function entropy(probs) {
      return -probs.reduce((sum, p) => p > 0 ? sum + p * Math.log2(p) : sum, 0);
    }

    function buildHuffmanTree(frequencies) {
      const nodes = Object.entries(frequencies)
        .map(([symbol, freq]) => ({ symbol, frequency: freq, left: null, right: null }))
        .sort((a, b) => a.frequency - b.frequency);

      while (nodes.length > 1) {
        const left = nodes.shift();
        const right = nodes.shift();
        const merged = {
          symbol: null,
          frequency: left.frequency + right.frequency,
          left: left,
          right: right
        };
        
        // Insert in sorted position
        let inserted = false;
        for (let i = 0; i < nodes.length; i++) {
          if (merged.frequency <= nodes[i].frequency) {
            nodes.splice(i, 0, merged);
            inserted = true;
            break;
          }
        }
        if (!inserted) nodes.push(merged);
      }
      
      return nodes[0];
    }

    function generateCodes(tree, code = '', codes = {}) {
      if (tree.symbol !== null) {
        codes[tree.symbol] = code || '0';
        return codes;
      }
      
      if (tree.left) generateCodes(tree.left, code + '0', codes);
      if (tree.right) generateCodes(tree.right, code + '1', codes);
      
      return codes;
    }

    function addNoise(bits, errorRate) {
      return bits.split('').map(bit => 
        Math.random() < errorRate ? (bit === '0' ? '1' : '0') : bit
      ).join('');
    }

    function repeatCode(bits, repetitions) {
      return bits.split('').map(bit => bit.repeat(repetitions)).join('');
    }

    function majorityDecode(encodedBits, repetitions) {
      let decoded = '';
      for (let i = 0; i < encodedBits.length; i += repetitions) {
        const chunk = encodedBits.slice(i, i + repetitions);
        const ones = (chunk.match(/1/g) || []).length;
        decoded += ones > repetitions / 2 ? '1' : '0';
      }
      return decoded;
    }

    // Update probability displays
    function updateProbabilities() {
      const pA = parseFloat(document.getElementById('probA').value);
      const pB = parseFloat(document.getElementById('probB').value);
      const pC = Math.max(0, 1 - pA - pB);

      // Ensure probabilities sum to 1
      if (pA + pB > 1) {
        const scale = 0.99 / (pA + pB);
        document.getElementById('probA').value = (pA * scale).toFixed(2);
        document.getElementById('probB').value = (pB * scale).toFixed(2);
        return updateProbabilities();
      }

      // Update displays
      document.getElementById('probA-value').textContent = pA.toFixed(2);
      document.getElementById('probB-value').textContent = pB.toFixed(2);
      document.getElementById('probA-display').textContent = pA.toFixed(2);
      document.getElementById('probB-display').textContent = pB.toFixed(2);
      document.getElementById('probC-display').textContent = pC.toFixed(2);

      // Update bars
      document.getElementById('probA-bar').style.width = (pA * 100) + '%';
      document.getElementById('probB-bar').style.width = (pB * 100) + '%';
      document.getElementById('probC-bar').style.width = (pC * 100) + '%';

      // Update entropy
      const H = entropy([pA, pB, pC]);
      document.getElementById('entropy-value').textContent = H.toFixed(3);
      document.getElementById('efficiency-value').textContent = ((H / Math.log2(3)) * 100).toFixed(0) + '%';

      // Update chart
      if (typeof distributionChart !== 'undefined') {
        distributionChart.data.datasets[0].data = [pA, pB, pC];
        distributionChart.update();
      }

      // Regenerate codes when probabilities change
      generateHuffmanCodes();
      updateCodesDisplay();
    }

    // Generate Huffman codes based on current probabilities
    function generateHuffmanCodes() {
      const pA = parseFloat(document.getElementById('probA').value);
      const pB = parseFloat(document.getElementById('probB').value);
      const pC = 1 - pA - pB;
      
      const frequencies = { 'A': pA, 'B': pB, 'C': pC };
      
      // Handle edge cases
      const nonZeroSymbols = Object.entries(frequencies).filter(([_, freq]) => freq > 0);
      
      if (nonZeroSymbols.length === 1) {
        // Only one symbol has non-zero probability
        huffmanCodes = { [nonZeroSymbols[0][0]]: '0' };
        ['A', 'B', 'C'].forEach(symbol => {
          if (!huffmanCodes[symbol]) huffmanCodes[symbol] = '1';
        });
      } else if (nonZeroSymbols.length === 2) {
        // Two symbols
        huffmanCodes = {};
        huffmanCodes[nonZeroSymbols[0][0]] = '0';
        huffmanCodes[nonZeroSymbols[1][0]] = '1';
        ['A', 'B', 'C'].forEach(symbol => {
          if (!huffmanCodes[symbol]) huffmanCodes[symbol] = '10';
        });
      } else {
        // Three symbols - build proper tree
        const tree = buildHuffmanTree(frequencies);
        huffmanCodes = generateCodes(tree);
      }
    }

    // Generate random message
    function generateMessage() {
      const pA = parseFloat(document.getElementById('probA').value);
      const pB = parseFloat(document.getElementById('probB').value);
      const pC = 1 - pA - pB;
      const length = parseInt(document.getElementById('msgLength').value);
      
      messageSymbols = [];
      for (let i = 0; i < length; i++) {
        const r = Math.random();
        if (r < pA) messageSymbols.push('A');
        else if (r < pA + pB) messageSymbols.push('B');
        else messageSymbols.push('C');
      }
      
      document.getElementById('message-preview').textContent = messageSymbols.slice(0, 100).join('');
      
      // Generate new Huffman codes for current probabilities
      generateHuffmanCodes();
      updateCodesDisplay();
    }

    function updateCodesDisplay() {
      const method = document.getElementById('encodingMethod').value;
      let codes, methodName;
      
      if (method === 'huffman') {
        codes = huffmanCodes;
        methodName = 'Huffman Codes';
      } else {
        codes = fixedCodes;
        methodName = 'Fixed-Length Codes';
      }
      
      const codesText = `${methodName}:\n` + Object.entries(codes)
        .filter(([symbol]) => ['A', 'B', 'C'].includes(symbol))
        .map(([symbol, code]) => `${symbol}: ${code}`)
        .join('\n');
      document.getElementById('codes-display').textContent = codesText;
    }

    // Encode message
    function encodeMessage() {
      if (messageSymbols.length === 0) {
        alert('Generate a message first!');
        return;
      }
      
      const method = document.getElementById('encodingMethod').value;
      let codes;
      
      if (method === 'huffman') {
        codes = huffmanCodes;
        encodedBits = messageSymbols.map(symbol => codes[symbol]).join('');
        const avgBits = encodedBits.length / messageSymbols.length;
        document.getElementById('avgBits-value').textContent = avgBits.toFixed(3);
        
        const fixedBits = Math.ceil(Math.log2(3));
        const compression = ((fixedBits * messageSymbols.length - encodedBits.length) / (fixedBits * messageSymbols.length) * 100);
        document.getElementById('compression-value').textContent = compression.toFixed(1) + '%';
      } else {
        // Fixed-length encoding
        codes = fixedCodes;
        encodedBits = messageSymbols.map(symbol => codes[symbol]).join('');
        document.getElementById('avgBits-value').textContent = '2.000';
        document.getElementById('compression-value').textContent = '0.0%';
      }
      
      document.getElementById('totalBits-value').textContent = encodedBits.length;
      document.getElementById('encoded-preview').textContent = encodedBits.slice(0, 200);
      
      document.getElementById('encoding-status').style.display = 'flex';
      
      // Update encoding chart
      const pA = parseFloat(document.getElementById('probA').value);
      const pB = parseFloat(document.getElementById('probB').value);
      const pC = 1 - pA - pB;
      const H = entropy([pA, pB, pC]);
      const avgLen = encodedBits.length / messageSymbols.length;
      
      if (typeof encodingChart !== 'undefined') {
        encodingChart.data.datasets[0].data = [H, avgLen, 2];
        encodingChart.update();
      }
    }

    // Transmit message
    function transmitMessage() {
      if (encodedBits === '') {
        alert('Encode a message first!');
        return;
      }
      
      const errorRate = parseFloat(document.getElementById('errorRate').value);
      const correction = document.getElementById('errorCorrection').value;
      
      let transmittedBits = encodedBits;
      let overhead = 1;
      
      // Apply error correction
      if (correction === 'repetition3') {
        transmittedBits = repeatCode(encodedBits, 3);
        overhead = 3;
      } else if (correction === 'repetition5') {
        transmittedBits = repeatCode(encodedBits, 5);
        overhead = 5;
      }
      
      // Add channel noise
      const noisyBits = addNoise(transmittedBits, errorRate);
      
      // Decode with error correction
      let decodedBits = noisyBits;
      if (correction === 'repetition3') {
        decodedBits = majorityDecode(noisyBits, 3);
      } else if (correction === 'repetition5') {
        decodedBits = majorityDecode(noisyBits, 5);
      }
      
      // Calculate metrics
      const inputErrors = transmittedBits.split('').reduce((count, bit, i) => 
        count + (bit !== noisyBits[i] ? 1 : 0), 0);
      const outputErrors = encodedBits.split('').reduce((count, bit, i) => 
        count + (bit !== decodedBits[i] ? 1 : 0), 0);
      
      const inputBER = (inputErrors / transmittedBits.length * 100);
      const outputBER = (outputErrors / encodedBits.length * 100);
      const errorsFixed = Math.max(0, Math.round(inputErrors / overhead) - outputErrors);
      
      // Update displays
      document.getElementById('bitsSent-value').textContent = transmittedBits.length;
      document.getElementById('overhead-value').textContent = overhead + 'x';
      document.getElementById('errorsFixed-value').textContent = errorsFixed;
      document.getElementById('inputBER-value').textContent = inputBER.toFixed(2) + '%';
      document.getElementById('outputBER-value').textContent = outputBER.toFixed(2) + '%';
      
      // Quality assessment
      let quality, statusClass;
      if (outputBER === 0) { quality = 'Perfect'; statusClass = 'status-success'; }
      else if (outputBER < 1) { quality = 'Excellent'; statusClass = 'status-success'; }
      else if (outputBER < 5) { quality = 'Good'; statusClass = 'status-warning'; }
      else { quality = 'Poor'; statusClass = 'status-error'; }
      
      document.getElementById('quality-value').textContent = quality;
      
      const statusEl = document.getElementById('transmission-status');
      statusEl.className = 'status-indicator ' + statusClass;
      statusEl.style.display = 'flex';
      statusEl.innerHTML = `<i class="fas ${outputBER === 0 ? 'fa-check-circle' : 'fa-exclamation-triangle'}"></i><span>BER: ${outputBER.toFixed(2)}%</span>`;
      
      // Update trade-off chart
      updateTradeoffChart(overhead, outputBER);
    }

    function updateTradeoffChart(overhead, outputBER) {
      if (typeof tradeoffChart !== 'undefined') {
        const efficiency = (1 / overhead) * 100;
        tradeoffChart.data.datasets[0].data = [{ x: efficiency, y: outputBER }];
        tradeoffChart.update();
      }
    }

    // Event listeners
    document.getElementById('probA').addEventListener('input', updateProbabilities);
    document.getElementById('probB').addEventListener('input', updateProbabilities);
    document.getElementById('msgLength').addEventListener('input', function() {
      document.getElementById('msgLength-value').textContent = this.value;
    });
    document.getElementById('errorRate').addEventListener('input', function() {
      document.getElementById('errorRate-value').textContent = parseFloat(this.value).toFixed(3);
    });

    // Add event listener for encoding method change
    document.getElementById('encodingMethod').addEventListener('change', updateCodesDisplay);

    document.getElementById('generateMsg').addEventListener('click', generateMessage);
    document.getElementById('encodeMsg').addEventListener('click', encodeMessage);
    document.getElementById('transmitMsg').addEventListener('click', transmitMessage);

    // Initialize charts
    const distributionChart = new Chart(document.getElementById('distributionChart'), {
      type: 'bar',
      data: {
        labels: ['Symbol A', 'Symbol B', 'Symbol C'],
        datasets: [{
          label: 'Probability',
          data: [0.7, 0.2, 0.1],
          backgroundColor: ['#6ea8fe', '#60d394', '#ff6b6b'],
          borderRadius: 6
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: 'Symbol Probability Distribution' },
          legend: { display: false }
        },
        scales: {
          y: { beginAtZero: true, max: 1, title: { display: true, text: 'Probability' } }
        }
      }
    });

    const encodingChart = new Chart(document.getElementById('encodingChart'), {
      type: 'bar',
      data: {
        labels: ['Entropy Limit', 'Chosen Method', 'Fixed Length'],
        datasets: [{
          label: 'Bits per Symbol',
          data: [1.157, 1.157, 2],
          backgroundColor: ['#ffb454', '#6ea8fe', '#9fb0c3'],
          borderRadius: 6
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: 'Encoding Efficiency Comparison' },
          legend: { display: false }
        },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'Bits per Symbol' } }
        }
      }
    });

    const tradeoffChart = new Chart(document.getElementById('tradeoffChart'), {
      type: 'scatter',
      data: {
        datasets: [{
          label: 'Current Configuration',
          data: [{ x: 100, y: 0 }],
          backgroundColor: '#6ea8fe',
          pointRadius: 8,
          pointHoverRadius: 12
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: 'Efficiency vs Reliability Trade-off' },
          legend: { display: false }
        },
        scales: {
          x: { 
            title: { display: true, text: 'Bandwidth Efficiency (%)' },
            min: 0, max: 100
          },
          y: { 
            title: { display: true, text: 'Bit Error Rate (%)' },
            min: 0, max: 20
          }
        }
      }
    });

    // Initialize
    updateProbabilities();
    generateMessage();

    // Mobile menu toggle function (keeping this for compatibility with script.js)
    window.toggleMobileMenu = function() {
      const menu = document.getElementById('mobile-menu');
      if (menu) {
        menu.classList.toggle('active');
      }
    };

    // Theme handling (keeping localStorage functionality but removing button)
    function applyTheme() {
      const isDark = document.documentElement.classList.contains('dark');
      const textColor = isDark ? '#ffffff' : '#000000';
      const gridColor = isDark ? '#333333' : '#e0e0e0';
      
      [distributionChart, encodingChart, tradeoffChart].forEach(chart => {
        if (chart && chart.options) {
          chart.options.plugins.title.color = textColor;
          if (chart.options.scales.x) {
            chart.options.scales.x.ticks = { color: textColor };
            chart.options.scales.x.grid = { color: gridColor };
            if (chart.options.scales.x.title) chart.options.scales.x.title.color = textColor;
          }
          if (chart.options.scales.y) {
            chart.options.scales.y.ticks = { color: textColor };
            chart.options.scales.y.grid = { color: gridColor };
            if (chart.options.scales.y.title) chart.options.scales.y.title.color = textColor;
          }
          chart.update();
        }
      });
    }

    // Apply theme on load
    setTimeout(applyTheme, 100);


// Also apply theme when theme toggle is clicked (if button exists)
const themeToggle = document.getElementById('theme-toggle');
if (themeToggle) {
  themeToggle.addEventListener('click', function() {
    setTimeout(applyTheme, 50); // Small delay to let theme change take effect
  });
}
  </script>
</body>
</html>