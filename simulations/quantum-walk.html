<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Random Walk - Interactive Demo</title>
  <style>
    :root {
      --bg-primary: #0a0e1a;
      --bg-secondary: #141b2d;
      --surface: #1e2a42;
      --surface-hover: #253655;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --accent-quantum: #3b82f6;
      --accent-classical: #f59e0b;
      --accent-validation: #10b981;
      --accent-quantum-light: rgba(59, 130, 246, 0.2);
      --accent-classical-light: rgba(245, 158, 11, 0.2);
      --border: #334155;
      --grid: #1e293b;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
      min-height: 100vh;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr;
        gap: 20px;
      }
    }
        
    .back-button {
      position: fixed;
      top: 16px;
      left: 16px;

      /* Background & transparency */
      background: rgba(18, 24, 38, 0.7); /* semi-transparent */
      backdrop-filter: blur(4px);        /* subtle glass effect */

      /* Text */
      color: var(--text-primary);
      font-family: "Segoe UI", sans-serif; /* change to any font you like */
      font-size: 16px;                     /* adjust size */
      font-weight: 500;

      /* Shape & spacing */
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 18px;

      /* Interactivity */
      cursor: pointer;
      z-index: 1000;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .back-button:hover {
      background: rgba(18, 24, 38, 0.9); /* less transparent on hover */
      transform: scale(1.05);            /* slight grow effect */
    }

    .header {
      grid-column: 1 / -1;
      text-align: center;
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: clamp(24px, 4vw, 36px);
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-quantum), var(--accent-classical));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 16px;
      max-width: 600px;
      margin: 0 auto;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .card-header {
      padding: 20px 24px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .card-title {
      font-size: 20px;
      font-weight: 600;
    }

    .card-body {
      padding: 24px;
    }

    .plot-container {
      position: relative;
    }

    .canvas {
      width: 100%;
      height: 500px;
      background: linear-gradient(180deg, var(--bg-primary), var(--bg-secondary));
      border-radius: 12px;
      border: 1px solid var(--border);
      display: block;
    }

    .legend {
      display: flex;
      gap: 20px;
      margin-top: 16px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid var(--border);
    }

    .legend-color.quantum {
      background: var(--accent-quantum);
    }

    .legend-color.classical {
      background: var(--accent-classical);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 24px;
    }

    @media (max-width: 640px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .control-value {
      color: var(--accent-quantum);
      font-weight: 600;
    }

    .slider {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      outline: none;
      border: 1px solid var(--border);
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--accent-quantum);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--surface);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--accent-quantum);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--surface);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .select {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .select:focus {
      outline: none;
      border-color: var(--accent-quantum);
    }

    .button-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 24px;
    }

    .button {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 16px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .button:hover {
      background: var(--surface-hover);
      transform: translateY(-1px);
    }

    .button:active {
      transform: translateY(0);
    }

    .button.primary {
      background: var(--accent-quantum);
      border-color: var(--accent-quantum);
    }

    .button.primary:hover {
      background: #2563eb;
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .validation-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
    }

    .validation-section h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--accent-validation);
    }

    .test-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .test-button {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .test-button:hover {
      background: var(--surface-hover);
      border-color: var(--accent-validation);
    }

    .info-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-top: 24px;
    }

    .info-section h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--accent-quantum);
    }

    .info-section p {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .info-section code {
      background: var(--surface);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
      color: var(--accent-classical);
    }

    .step-indicator {
      font-size: 14px;
      color: var(--accent-quantum);
      font-weight: 600;
    }

    .highlight-box {
      background: var(--accent-quantum-light);
      border: 1px solid var(--accent-quantum);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }

    .highlight-box h4 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--accent-quantum);
    }

    .highlight-box p {
      font-size: 13px;
      line-height: 1.5;
    }

    .stats-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      font-size: 12px;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .stat-label {
      color: var(--text-secondary);
    }

    .stat-value {
      color: var(--text-primary);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <button class="back-button" onclick="handleBack()">← Back</button>
  <div class="container">
    <div class="header">
      <h1>Quantum Random Walk (1D)</h1>
      <p>Explore the difference between quantum and classical random walks in 1D. Watch how quantum interference creates ballistic spreading instead of classical diffusion.</p>
    </div>

    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Probability Distribution</h2>
        <span class="step-indicator" id="stepCounter">Step: 0</span>
      </div>
      <div class="card-body">
        <div class="plot-container">
          <canvas id="plotCanvas" class="canvas"></canvas>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color quantum"></div>
            <span>Quantum Walk</span>
          </div>
          <div class="legend-item">
            <div class="legend-color classical"></div>
            <span>Classical Walk</span>
          </div>
        </div>
        <div class="stats-section">
          <div class="stats-grid">
            <div class="stat-item">
              <span class="stat-label">Quantum σ²:</span>
              <span class="stat-value" id="quantumVariance">0.00</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Classical σ²:</span>
              <span class="stat-value" id="classicalVariance">0.00</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Q/C Variance Ratio:</span>
              <span class="stat-value" id="varianceRatio">N/A</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Total Prob:</span>
              <span class="stat-value" id="totalProb">1.000</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Controls</h2>
      </div>
      <div class="card-body">
        <div class="validation-section">
          <h3>Validation Tests</h3>
          <div class="test-buttons">
            <button class="test-button" onclick="app.loadTest('stationary')">θ=90° |L⟩ (Localized)</button>
            <button class="test-button" onclick="app.loadTest('symmetric')">θ=0° |+⟩ (Ballistic)</button>
            <button class="test-button" onclick="app.loadTest('biased')">θ=45° |L⟩ (Biased)</button>
            <button class="test-button" onclick="app.loadTest('biasedr')">θ=45° |R⟩ (Biased)</button>
            <button class="test-button" onclick="app.loadTest('hadamard')">Hadamard Walk (Standard)</button>
            <button class="test-button" onclick="app.loadTest('decoherent')">Full Decoherence</button>
          </div>
        </div>

        <div class="controls-grid">
          <div class="control-group">
            <label class="control-label">
              Max Steps
              <span class="control-value" id="maxStepsValue">50</span>
            </label>
            <input type="range" class="slider" id="maxStepsSlider" min="1" max="100" value="50">
          </div>

          <div class="control-group">
            <label class="control-label">
              Coin Angle θ
              <span class="control-value" id="thetaValue">45°</span>
            </label>
            <input type="range" class="slider" id="thetaSlider" min="0" max="90" step="1" value="45">
          </div>

          <div class="control-group">
            <label class="control-label">
              Initial Phase φ
              <span class="control-value" id="phaseValue">0°</span>
            </label>
            <input type="range" class="slider" id="phaseSlider" min="0" max="360" step="5" value="90">
          </div>

          <div class="control-group">
            <label class="control-label">Initial Coin State</label>
            <select class="select" id="initState">
              <option value="plus">(|L⟩ + |R⟩)/√2</option>
              <option value="minus">(|L⟩ - |R⟩)/√2</option>
              <option value="left">|L⟩</option>
              <option value="right">|R⟩</option>
            </select>
          </div>

          <div class="control-group">
            <label class="control-label">
              Decoherence Rate
              <span class="control-value" id="decoherenceValue">0.00</span>
            </label>
            <input type="range" class="slider" id="decoherenceSlider" min="0" max="1" step="0.01" value="0">
          </div>

          <div class="control-group">
            <label class="control-label">
              Animation Speed
              <span class="control-value" id="speedValue">50ms</span>
            </label>
            <input type="range" class="slider" id="speedSlider" min="10" max="200" step="10" value="40">
          </div>
        </div>

        <div class="button-group">
          <button class="button primary" id="playBtn">▶ Play Animation</button>
          <button class="button" id="pauseBtn">⏸ Pause</button>
          <button class="button" id="stepBtn">Single Step</button>
          <button class="button" id="resetBtn">Reset to Origin</button>
        </div>

        <div class="info-section">
          <h3>What You're Seeing</h3>
          <p>
            The quantum walk evolves in a space combining position <code>|x⟩</code> and coin states <code>|L⟩, |R⟩</code>. 
            Each step applies a coin rotation <code>C(θ)</code> followed by conditional shifts. 
            Quantum interference creates <strong>ballistic spreading</strong> (σ ∼ n) with peaks at ±n cos(θ), 
            unlike classical <strong>diffusive spreading</strong> (σ ∼ √n).
          </p>

          <div class="highlight-box">
            <h4>Key Physics & Validation</h4>
            <p>
              <strong>θ = 90°:</strong> No mixing, walker stays at origin<br>
              <strong>θ = 45°:</strong> Maximum quantum speedup, σ² ≈ n²/2<br>
              <strong>θ = 0°:</strong> Complete mixing, different interference<br>
              <strong>Full Decoherence:</strong> Should match a classical random walk<br>
              <strong>|L⟩ vs |R⟩ and |+⟩ vs |-⟩:</strong> Initial state affects symmetry
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function handleBack() {
      window.location.href = "../simulations.html";
    }
    // Complex number arithmetic
    class Complex {
      constructor(real = 0, imag = 0) {
        this.real = real;
        this.imag = imag;
      }

      add(other) {
        return new Complex(this.real + other.real, this.imag + other.imag);
      }

      multiply(other) {
        if (typeof other === 'number') {
          return new Complex(this.real * other, this.imag * other);
        }
        return new Complex(
          this.real * other.real - this.imag * other.imag,
          this.real * other.imag + this.imag * other.real
        );
      }

      magnitude() {
        return Math.sqrt(this.real * this.real + this.imag * this.imag);
      }

      magnitudeSquared() {
        return this.real * this.real + this.imag * this.imag;
      }

      conjugate() {
        return new Complex(this.real, -this.imag);
      }

      static fromPolar(magnitude, phase) {
        return new Complex(magnitude * Math.cos(phase), magnitude * Math.sin(phase));
      }
    }

    // Quantum Walker class with corrected decoherence
    class QuantumWalker {
      constructor(size = 201) {
        this.size = size;
        this.center = Math.floor(size / 2);
        this.reset();
      }

      reset() {
        this.psiLeft = new Array(this.size).fill(0).map(() => new Complex(0, 0));
        this.psiRight = new Array(this.size).fill(0).map(() => new Complex(0, 0));
        this.step = 0;
      }

      setInitialState(state, phase = 0) {
        this.reset();
        const sqrt2inv = 1 / Math.sqrt(2);
        const phaseComplex = Complex.fromPolar(1, phase * Math.PI / 180);

        switch (state) {
          case 'left':
            this.psiLeft[this.center] = new Complex(1, 0);
            break;
          case 'right':
            this.psiRight[this.center] = new Complex(1, 0);
            break;
          case 'plus':
            this.psiLeft[this.center] = new Complex(sqrt2inv, 0);
            this.psiRight[this.center] = new Complex(sqrt2inv, 0).multiply(phaseComplex);
            break;
          case 'minus':
            this.psiLeft[this.center] = new Complex(sqrt2inv, 0);
            this.psiRight[this.center] = new Complex(-sqrt2inv, 0).multiply(phaseComplex);
            break;
        }
      }

      evolveOneStep(theta, decoherenceRate = 0) {
        const thetaRad = theta * Math.PI / 180;
        const cos_theta = Math.cos(thetaRad);
        const sin_theta = Math.sin(thetaRad);

        const newPsiLeft = new Array(this.size).fill(0).map(() => new Complex(0, 0));
        const newPsiRight = new Array(this.size).fill(0).map(() => new Complex(0, 0));

        for (let x = 0; x < this.size; x++) {
          const psiL = this.psiLeft[x];
          const psiR = this.psiRight[x];

          // Skip if no amplitude at this position
          if (psiL.magnitudeSquared() + psiR.magnitudeSquared() < 1e-15) continue;

          // Apply coin operation - corrected matrix
          // Standard coin: C = [[cos θ, sin θ], [sin θ, -cos θ]]
          // |L'⟩ = cos θ |L⟩ + sin θ |R⟩  
          // |R'⟩ = sin θ |L⟩ - cos θ |R⟩
          let newL = psiL.multiply(cos_theta).add(psiR.multiply(sin_theta));
          let newR = psiL.multiply(sin_theta).add(psiR.multiply(-cos_theta));

          // Apply corrected decoherence model
          if (decoherenceRate > 0) {
            // With probability decoherenceRate, collapse to classical random step
            if (Math.random() < decoherenceRate) {
              const totalProb = newL.magnitudeSquared() + newR.magnitudeSquared();
              const probL = newL.magnitudeSquared() / totalProb;
              
              // Classical random step: go left or right based on probabilities
              if (Math.random() < probL) {
                // Go left with classical probability
                newL = new Complex(Math.sqrt(totalProb), 0);
                newR = new Complex(0, 0);
              } else {
                // Go right with classical probability  
                newL = new Complex(0, 0);
                newR = new Complex(Math.sqrt(totalProb), 0);
              }
            }
          }

          // Conditional shift
          if (x > 0 && newL.magnitudeSquared() > 1e-15) {
            newPsiLeft[x - 1] = newPsiLeft[x - 1].add(newL);
          }
          if (x < this.size - 1 && newR.magnitudeSquared() > 1e-15) {
            newPsiRight[x + 1] = newPsiRight[x + 1].add(newR);
          }
        }

        this.psiLeft = newPsiLeft;
        this.psiRight = newPsiRight;
        this.step++;

        // Normalize
        this.normalize();
      }

      normalize() {
        let norm = 0;
        for (let x = 0; x < this.size; x++) {
          norm += this.psiLeft[x].magnitudeSquared() + this.psiRight[x].magnitudeSquared();
        }
        norm = Math.sqrt(norm);

        if (norm > 1e-15) {
          for (let x = 0; x < this.size; x++) {
            this.psiLeft[x] = this.psiLeft[x].multiply(1 / norm);
            this.psiRight[x] = this.psiRight[x].multiply(1 / norm);
          }
        }
      }

      getProbabilityDistribution() {
        const probs = new Array(this.size);
        for (let x = 0; x < this.size; x++) {
          probs[x] = this.psiLeft[x].magnitudeSquared() + this.psiRight[x].magnitudeSquared();
        }
        return probs;
      }

      // Calculate variance for validation
      getVariance() {
        const probs = this.getProbabilityDistribution();
        let mean = 0;
        let totalProb = 0;

        for (let x = 0; x < this.size; x++) {
          mean += (x - this.center) * probs[x];
          totalProb += probs[x];
        }
        mean /= totalProb;

        let variance = 0;
        for (let x = 0; x < this.size; x++) {
          variance += Math.pow(x - this.center - mean, 2) * probs[x];
        }
        variance /= totalProb;

        return { variance, totalProb };
      }
    }

    // Classical random walk for comparison - corrected implementation
    function getClassicalDistribution(steps, size, center) {
      const probs = new Array(size).fill(0);
      if (steps === 0) {
        probs[center] = 1;
        return probs;
      }

      // Classical random walk: binomial distribution
      // P(position = center + k) = C(steps, (steps+k)/2) / 2^steps
      // where k must have same parity as steps and |k| <= steps
      
      for (let k = -steps; k <= steps; k += 2) {
        const x = center + k;
        if (x >= 0 && x < size) {
          const numRight = (steps + k) / 2;
          if (numRight >= 0 && numRight <= steps && numRight === Math.floor(numRight)) {
            // Calculate binomial coefficient C(steps, numRight)
            let coeff = 1;
            for (let i = 0; i < Math.min(numRight, steps - numRight); i++) {
              coeff = coeff * (steps - i) / (i + 1);
            }
            probs[x] = coeff / Math.pow(2, steps);
          }
        }
      }
      return probs;
    }

    // Calculate classical variance
    function getClassicalVariance(steps) {
      return steps; // Classical random walk variance is exactly n
    }

    // Plotting class
    class Plotter {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        this.drawWidth = rect.width;
        this.drawHeight = rect.height;
      }

      plot(quantumProbs, classicalProbs, centerIndex, step) {
        const ctx = this.ctx;
        const width = this.drawWidth || this.canvas.clientWidth;
        const height = this.drawHeight || this.canvas.clientHeight;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Set up plotting area
        const margin = { left: 80, right: 30, top: 30, bottom: 60 };
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;

        // Dynamic range based on step
        const displayHalfRange = Math.max(50, Math.min(100, step + 20));
        const minX = Math.max(0, centerIndex - displayHalfRange);
        const maxX = Math.min(quantumProbs.length - 1, centerIndex + displayHalfRange);
        const displayRange = maxX - minX;

        // Find maximum probability for scaling
        let maxProb = 1e-10;
        for (let i = minX; i <= maxX; i++) {
          maxProb = Math.max(maxProb, quantumProbs[i], classicalProbs[i]);
        }
        maxProb *= 1.1; // Add some headroom

        // Draw grid
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        // Horizontal grid lines
        for (let i = 0; i <= 5; i++) {
          const y = margin.top + (plotHeight * i) / 5;
          ctx.moveTo(margin.left, y);
          ctx.lineTo(margin.left + plotWidth, y);
        }
        
        // Vertical grid lines
        const gridSpacing = Math.max(10, Math.floor(displayRange / 10));
        for (let pos = minX; pos <= maxX; pos += gridSpacing) {
          if ((pos - centerIndex) % gridSpacing === 0) {
            const x = margin.left + ((pos - minX) / displayRange) * plotWidth;
            ctx.moveTo(x, margin.top);
            ctx.lineTo(x, margin.top + plotHeight);
          }
        }
        ctx.stroke();

        // Draw axes
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, margin.top + plotHeight);
        ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
        
        // Draw center line (x = 0)
        const centerX = margin.left + ((centerIndex - minX) / displayRange) * plotWidth;
        ctx.moveTo(centerX, margin.top);
        ctx.lineTo(centerX, margin.top + plotHeight);
        ctx.stroke();

        // Draw classical distribution (smooth line)
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        let firstPoint = true;
        for (let i = minX; i <= maxX; i++) {
          const x = margin.left + ((i - minX) / displayRange) * plotWidth;
          const y = margin.top + plotHeight - (classicalProbs[i] / maxProb) * plotHeight;
          if (firstPoint) {
            ctx.moveTo(x, y);
            firstPoint = false;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw quantum distribution (bars)
        ctx.fillStyle = '#3b82f6';
        const barWidth = plotWidth / displayRange;
        for (let i = minX; i <= maxX; i++) {
          if (quantumProbs[i] > 1e-15) {
            const x = margin.left + ((i - minX) / displayRange) * plotWidth;
            const barHeight = (quantumProbs[i] / maxProb) * plotHeight;
            const y = margin.top + plotHeight - barHeight;
            ctx.fillRect(x, y, Math.max(1, barWidth * 0.8), barHeight);
          }
        }

        // Draw labels
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px -apple-system, system-ui';

        // Y-axis labels
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 5; i++) {
          const y = margin.top + (plotHeight * i) / 5;
          const value = (maxProb * (5 - i) / 5);
          const label = value < 0.01 ? value.toExponential(1) : value.toFixed(3);
          ctx.fillText(label, margin.left - 10, y);
        }

        // X-axis labels
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let pos = minX; pos <= maxX; pos += gridSpacing) {
          if ((pos - centerIndex) % gridSpacing === 0) {
            const x = margin.left + ((pos - minX) / displayRange) * plotWidth;
            const position = pos - centerIndex;
            ctx.fillText(position.toString(), x, margin.top + plotHeight + 10);
          }
        }

        // Axis titles
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '14px -apple-system, system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Position', margin.left + plotWidth/2, height - 15);
        
        ctx.save();
        ctx.translate(20, margin.top + plotHeight/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText('Probability', 0, 0);
        ctx.restore();
      }
    }

    // Main application
    class QuantumWalkApp {
      constructor() {
        this.walker = new QuantumWalker(201);
        this.plotter = new Plotter(document.getElementById('plotCanvas'));
        this.animationId = null;
        this.isPlaying = false;
        
        this.setupEventListeners();
        this.updateAll();
      }

      setupEventListeners() {
        // Sliders
        document.getElementById('maxStepsSlider').addEventListener('input', () => this.updateMaxSteps());
        document.getElementById('thetaSlider').addEventListener('input', () => this.updateTheta());
        document.getElementById('phaseSlider').addEventListener('input', () => this.updatePhase());
        document.getElementById('decoherenceSlider').addEventListener('input', () => this.updateDecoherence());
        document.getElementById('speedSlider').addEventListener('input', () => this.updateSpeed());
        
        // Select
        document.getElementById('initState').addEventListener('change', () => this.updateInitState());
        
        // Buttons
        document.getElementById('playBtn').addEventListener('click', () => this.playAnimation());
        document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
        document.getElementById('stepBtn').addEventListener('click', () => this.singleStep());
        document.getElementById('resetBtn').addEventListener('click', () => this.reset());

        // Handle window resize
        window.addEventListener('resize', () => {
          this.plotter.setupCanvas();
          this.render();
        });
      }

      updateMaxSteps() {
        const steps = parseInt(document.getElementById('maxStepsSlider').value);
        document.getElementById('maxStepsValue').textContent = steps.toString();
      }

      updateTheta() {
        const theta = parseInt(document.getElementById('thetaSlider').value);
        document.getElementById('thetaValue').textContent = theta + '°';
        
        if (!this.isPlaying) {
          this.reset();
        }
      }

      updatePhase() {
        const phase = parseInt(document.getElementById('phaseSlider').value);
        document.getElementById('phaseValue').textContent = phase + '°';
        
        if (!this.isPlaying) {
          this.reset();
        }
      }

      updateDecoherence() {
        const decoherence = parseFloat(document.getElementById('decoherenceSlider').value);
        document.getElementById('decoherenceValue').textContent = decoherence.toFixed(2);
        
        if (!this.isPlaying) {
          this.reset();
        }
      }

      updateSpeed() {
        const speed = parseInt(document.getElementById('speedSlider').value);
        document.getElementById('speedValue').textContent = speed + 'ms';
      }

      updateInitState() {
        if (!this.isPlaying) {
          this.reset();
        }
      }

      reset() {
        this.pause();
        
        const initState = document.getElementById('initState').value;
        const phase = parseInt(document.getElementById('phaseSlider').value);
        
        this.walker.setInitialState(initState, phase);
        this.render();
      }

      playAnimation() {
        if (this.isPlaying) return;
        
        // Always start from step 0
        this.reset();
        
        this.isPlaying = true;
        const maxSteps = parseInt(document.getElementById('maxStepsSlider').value);
        const speed = parseInt(document.getElementById('speedSlider').value);
        const theta = parseInt(document.getElementById('thetaSlider').value);
        const decoherence = parseFloat(document.getElementById('decoherenceSlider').value);

        // Disable play button during animation
        document.getElementById('playBtn').disabled = true;

        const animate = () => {
          if (!this.isPlaying || this.walker.step >= maxSteps) {
            this.isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            return;
          }

          this.walker.evolveOneStep(theta, decoherence);
          this.render();

          this.animationId = setTimeout(animate, speed);
        };

        animate();
      }

      pause() {
        this.isPlaying = false;
        document.getElementById('playBtn').disabled = false;
        if (this.animationId) {
          clearTimeout(this.animationId);
          this.animationId = null;
        }
      }

      singleStep() {
        if (this.isPlaying) return;
        
        const theta = parseInt(document.getElementById('thetaSlider').value);
        const decoherence = parseFloat(document.getElementById('decoherenceSlider').value);
        
        this.walker.evolveOneStep(theta, decoherence);
        this.render();
      }

      render() {
        const quantumProbs = this.walker.getProbabilityDistribution();
        const classicalProbs = getClassicalDistribution(this.walker.step, this.walker.size, this.walker.center);
        
        this.plotter.plot(quantumProbs, classicalProbs, this.walker.center, this.walker.step);
        
        // Update step counter
        document.getElementById('stepCounter').textContent = `Step: ${this.walker.step}`;
        
        // Update statistics
        const quantumStats = this.walker.getVariance();
        const classicalVariance = getClassicalVariance(this.walker.step);
        
        document.getElementById('quantumVariance').textContent = quantumStats.variance.toFixed(2);
        document.getElementById('classicalVariance').textContent = classicalVariance.toFixed(2);
        document.getElementById('totalProb').textContent = quantumStats.totalProb.toFixed(3);
        
        if (classicalVariance > 0) {
          const ratio = quantumStats.variance / classicalVariance;
          document.getElementById('varianceRatio').textContent = ratio.toFixed(2);
        } else {
          document.getElementById('varianceRatio').textContent = 'N/A';
        }
      }

      // Validation test cases
      loadTest(testName) {
        this.pause();
        
        switch (testName) {
          case 'stationary':
            // θ = 90°, |L⟩ or |R⟩ state, should stay localized
            document.getElementById('thetaSlider').value = '90';
            document.getElementById('initState').value = 'left';
            document.getElementById('decoherenceSlider').value = '0';
            document.getElementById('maxStepsSlider').value = '20';
            break;
            
          case 'symmetric':
            // θ = 0°, |+⟩ state, should create symmetric ballistic spreading
            document.getElementById('thetaSlider').value = '0';
            document.getElementById('initState').value = 'plus';
            document.getElementById('decoherenceSlider').value = '0';
            document.getElementById('maxStepsSlider').value = '50';
            break;
            
          case 'biased':
            // θ = 45°, |L⟩ state, should be biased left
            document.getElementById('thetaSlider').value = '45';
            document.getElementById('initState').value = 'left';
            document.getElementById('decoherenceSlider').value = '0';
            document.getElementById('maxStepsSlider').value = '80';
            break;

          case 'biasedr':
            // θ = 45°, |R⟩ state, should be biased right
            document.getElementById('thetaSlider').value = '45';
            document.getElementById('initState').value = 'right';
            document.getElementById('decoherenceSlider').value = '0';
            document.getElementById('maxStepsSlider').value = '80';
            break;
            
          case 'decoherent':
            // Full decoherence, should match classical RW
            document.getElementById('thetaSlider').value = '45';
            document.getElementById('initState').value = 'plus';
            document.getElementById('decoherenceSlider').value = '1.0';
            document.getElementById('maxStepsSlider').value = '50';
            break;
            
          case 'hadamard':
            // True Hadamard walk - θ=45°, |+⟩, should show symmetric ballistic spreading
            document.getElementById('thetaSlider').value = '45';
            document.getElementById('initState').value = 'plus';
            document.getElementById('decoherenceSlider').value = '0';
            document.getElementById('phaseSlider').value = '90';
            document.getElementById('maxStepsSlider').value = '80';
            break;
        }
        
        this.updateAll();
        this.reset();
      }

      updateAll() {
        this.updateMaxSteps();
        this.updateTheta();
        this.updatePhase();
        this.updateDecoherence();
        this.updateSpeed();
        this.updateInitState();
      }
    }

    // Global app instance for test buttons
    let app;

    // Initialize the application when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      app = new QuantumWalkApp();
    });
  </script>
</body>
</html>